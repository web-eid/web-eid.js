import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing';
import { TestBed } from '@angular/core/testing';
import { provideHttpClient } from '@angular/common/http';
import { LibraryAuthenticateResponse } from '@web-eid/web-eid-library/models/message/LibraryResponse';

import { AuthService } from './auth.service';
import { LanguageService } from './language.service';
import { WebEidService } from './web-eid.service';

describe('AuthService', () => {
  let service: AuthService;
  let httpMock: HttpTestingController;
  let languageService: jasmine.SpyObj<LanguageService>;
  let webEidService: jasmine.SpyObj<WebEidService>;
  let isLoggedInSignal: () => boolean;

  async function login() {
    const nonce = 'a base64-encoded cryptographic nonce, generated by the server, with at least 256 bits of entropy';
    const authToken: LibraryAuthenticateResponse = {
      unverifiedCertificate: 'fake-cert',
      algorithm: 'ES384',
      signature: 'fake-signature',
      format: 'web-eid:1.0',
      appVersion: 'https://web-eid.eu/web-eid-app/releases/2.3.4+fakeversion'
    };

    webEidService.authenticate.and.returnValue(
      Promise.resolve(authToken)
    );
    languageService.language.and.returnValue('en');

    const authPromise = service.authenticate();
    let req = httpMock.expectOne('/auth/challenge');
    expect(req.request.method).toBe('GET');
    req.flush({ nonce });

    await new Promise((resolve) => setTimeout(resolve, 100));

    req = httpMock.expectOne('/auth/login');
    expect(req.request.method).toBe('POST');
    expect(req.request.body).toEqual({ 'auth-token': authToken });
    req.flush({});

    await authPromise;

    expect(isLoggedInSignal()).toBeTrue();
  }

  beforeEach(() => {
    const languageServiceSpy = jasmine.createSpyObj('LanguageService', ['language']);
    const webEidServiceSpy = jasmine.createSpyObj(
      'WebEidService', 
      ['status', 'authenticate', 'getSigningCertificate', 'sign']
    );

    TestBed.configureTestingModule({
      providers: [
        provideHttpClient(),
        provideHttpClientTesting(),
        AuthService,
        { provide: LanguageService, useValue: languageServiceSpy },
        { provide: WebEidService, useValue: webEidServiceSpy }
      ]
    });

    service = TestBed.inject(AuthService);
    httpMock = TestBed.inject(HttpTestingController);
    languageService = TestBed.inject(LanguageService) as jasmine.SpyObj<LanguageService>;
    webEidService = TestBed.inject(WebEidService) as jasmine.SpyObj<WebEidService>;
    isLoggedInSignal = service.isLoggedIn;
  });

  afterEach(() => {
    httpMock.verify();
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should set loggedIn to true on successful user data fetch', async () => {
    const statusPromise = service.fetchUserInfo();

    const req = httpMock.expectOne('/auth/user');
    expect(req.request.method).toBe('GET');
    req.flush({ sub: 'testuser', auth: '[ROLE_USER]' });

    await statusPromise;

    expect(isLoggedInSignal()).toBeTrue();
  });

  it('should set loggedIn to false on failed user data fetch', async () => {
    service.fetchUserInfo();
    const req = httpMock.expectOne('/auth/user');
    expect(req.request.method).toBe('GET');
    req.flush('Unauthorized', { status: 401, statusText: 'Unauthorized' });

    expect(isLoggedInSignal()).toBeFalse();
  });

  it('should authenticate successfully', async () => {
    await login();
  });

  it('should handle authentication error', async () => {
    const nonce = 'a base64-encoded cryptographic nonce, generated by the server, with at least 256 bits of entropy';
  
    webEidService.authenticate.and.returnValue(Promise.reject('Authentication failed'));
    languageService.language.and.returnValue('en');
  
    const authPromise = service.authenticate();
  
    const req = httpMock.expectOne('/auth/challenge');
    expect(req.request.method).toBe('GET');
    req.flush({ nonce });
  
    await expectAsync(authPromise).toBeRejectedWith('Authentication failed');
   
    expect(isLoggedInSignal()).toBeFalse();
  });

  it('should logout successfully', async () => {
    await login();
    
    const logoutPromise = service.logout();

    let req = httpMock.expectOne('/auth/logout');
    expect(req.request.method).toBe('POST');
    req.flush({});

    await logoutPromise;

    expect(isLoggedInSignal()).toBeFalse();
  });

  it('should handle logout error', async () => {
    await login();

    const logoutPromise = service.logout();

    const req = httpMock.expectOne('/auth/logout');
    expect(req.request.method).toBe('POST');
    req.flush('Network error', { status: 500, statusText: 'Network error' });

    try {
      await logoutPromise;
    } catch (error) {
      expect(error).toBeTruthy();
    }

    expect(isLoggedInSignal()).toBeTrue();
  });
});
